# vagrant plugin install vagrant-libvirt
require 'fileutils'

Vagrant.configure("2") do |config|
  # Uncomment this depending on the provider you want to use
  ENV['VAGRANT_DEFAULT_PROVIDER'] = 'libvirt'
  management_network_prefix = "192.168.121"
  storage_pool_name = "vms"
  efi_path='/var/lib/libvirt/images/efi'
  owner = 'jubeaz'
  group = 'libvirt-qemu'
  permissions = 0666  # This is octal for 664
  bridge = {
    dev: "br0",
    name: "virbr_plaber",
    mask: "255.255.255.0",
    network: "192.168.10",
    gw: "192.168.10.254"
  }
#   bridge: {name: "br1", mask: "255.255.0.0", network: "192.168.58.0", gw: "192.168.2.1"}
  net_defs = { 
    weyland: {
      name: "weyland",  
      mask: "255.255.255.0", 
      network: "172.17.1", 
      gw: "172.17.1.254"
    },
  	haas: {
      name: "haas",
      mask: "255.255.255.0",
      network: "172.17.2",
      gw: "172.17.2.254"
    },
  	research: {
      name: "research",
      mask: "255.255.255.0",
      network: "172.17.3",
      gw: "172.17.3.254"
    }
  }

  box_defs = [
    { 
      role: "firewall",
      # deployment_type: "nat", # "routed" will exploit bridge interface anything else else will rely on NAT
      deployment_type: "routed", # "routed" will exploit bridge interface anything else else will rely on NAT
      bname: "nrunner_fw", 
    	nets: [
    		{
    			relative_ip: "254",
          net: net_defs[:haas], 
    		},
    		{
    			relative_ip: "254",
          net: net_defs[:weyland], 
    		},
    		{
    			relative_ip: "254",
          net: net_defs[:research], 
    		}
    	],
      ip_p: "192.168.10.100",
      # box_img: "archlinux/archlinux", 
      # box_img_version: "20241001.267073", 
      box_img: "qemu-jubeaz-bios-archlinux-x86_64",
      username: "jubeaz",
      password: "jubeaz",
      os: "arch", 
      ram: 1*1024,
      cpu: 1,
      firmware: "bios"
    },
#    { 
#      # only internal
#      role: "member",
#      bname: "nrunner_wld_dc", 
#  	  net: net_defs[:weyland], 
#      relative_ip: "2", 
#      #box_img: "qemu-jubeaz-uefi-windows-2022",
#      box_img: "qemu-jubeaz-uefi-windows-2022",
#      username: "jubeaz",
#      password: "jubeaz",
#      os: "windows", 
#      ram: 2*1024,
#      cpu: 2,
#      firmware: "uefi"
#    },
#    { 
#      # internal and public
#      role: "member",
#      bname: "nrunner_wld_srv01", 
#      relative_ip: "10", 
#  	  net: net_defs[:weyland], 
#      box_img: "qemu-jubeaz-uefi-windows-2022",
#      username: "jubeaz",
#      password: "jubeaz",
#      os: "windows", 
#      #ram: 2*1024,
#      ram: 4*1024,
#      cpu: 2,
#      firmware: "uefi"
#    },
    { 
      # only internal
      role: "member",
      bname: "nrunner_haas_dc", 
      relative_ip: "2", 
  	  net: net_defs[:haas], 
      box_img: "qemu-jubeaz-uefi-windows-2022",
      username: "jubeaz",
      password: "jubeaz",
      os: "windows", 
      ram: 2*1024,
      # ram: 4*1024,
      cpu: 2,
      firmware: "uefi"
    },
    { 
      # only internal
      role: "member",
      bname: "nrunner_haas_srv01", 
      relative_ip: "10", 
  	  net: net_defs[:haas], 
      box_img: "qemu-jubeaz-uefi-windows-2022",
      username: "jubeaz",
      password: "jubeaz",
      os: "windows", 
      # ram: 2*1024,
      ram: 4*1024,
      cpu: 2,
      firmware: "uefi"
    },
    { 
      # only internal
      role: "member",
      bname: "nrunner_haas_srv02", 
      relative_ip: "11", 
  	   net: net_defs[:haas], 
      box_img: "qemu-jubeaz-uefi-windows-2022",
      username: "jubeaz",
      password: "jubeaz",
      os: "windows", 
      #ram: 2*1024,
      ram: 4*1024,
      cpu: 2,
      firmware: "uefi"
    },
    { 
      # only internal
      role: "member",
      bname: "nrunner_haas_srv03", 
      relative_ip: "12", 
  	  net: net_defs[:haas], 
      box_img: "qemu-jubeaz-uefi-windows-2022",
      username: "jubeaz",
      password: "jubeaz",
      os: "windows", 
      #ram: 2*1024,
      ram: 4*1024,
      cpu: 2,
      firmware: "uefi"
    },
    { 
      # only internal
      role: "member",
      bname: "nrunner_haas_ws01", 
      relative_ip: "20", 
  	   net: net_defs[:haas], 
      box_img: "qemu-jubeaz-uefi-windows-2022",
      username: "jubeaz",
      password: "jubeaz",
      os: "windows", 
      #ram: 2*1024,
      ram: 4*1024,
      cpu: 2,
      firmware: "uefi"
    }
#    { 
#      # only internal
#      role: "member",
#      bname: "nrunner_rsc_dc", 
#      relative_ip: "2", 
#  	  net: net_defs[:research], 
#      box_img: "qemu-jubeaz-uefi-windows-2022",
#      username: "jubeaz",
#      password: "jubeaz",
#      os: "windows", 
#      ram: 2*1024,
#      cpu: 2,
#      firmware: "uefi"
#    },
#    { 
#      # only internal
#      role: "member",
#      bname: "nrunner_rsc_srv01", 
#      relative_ip: "10", 
#  	  net: net_defs[:research], 
#      #box: "gusztavvargadr/windows-server-core",
#      box: "gusztavvargadr/windows-server",
#      #box_version: "2102.0.2409",  
#      os: "windows", 
#      #ram: 2*1024,
#      ram: 4*1024,
#      cpu: 2,
#      firmware: "uefi"
#    },
#    { 
#      # only internal
#      role: "member",
#      bname: "nrunner_rsc_ws01", 
#      relative_ip: "20", 
#  	  net: net_defs[:research], 
#      box_img: "qemu-jubeaz-uefi-windows-2022",
#      username: "jubeaz",
#      password: "jubeaz",
#      os: "windows", 
#      #ram: 2*1024,
#      ram: 4*1024,
#      cpu: 2,
#      firmware: "uefi"
#    }
#    { 
#      # only internal
#      role: "member",
#      bname: "bastion", 
#      relative_ip: "20", 
#  	   net: net_defs[:haas], 
#      box_img: "bastion-12.0.14", # create_vm.sh bastion-openstack.qcow2 bastion-12.0.14.qcow2
#      username: "jubeaz",
#      password: "jubeaz",
#      os: "linux", 
#      #ram: 2*1024,
#      ram: 4*1024,
#      cpu: 2,
#      firmware: "bios"
#    }
  ]
# NVRAM_PATH="#{config.vm.provider(:libvirt).nvram}"
  config.trigger.after :destroy do |trigger|
    trigger.name = "Delete nvram"
    trigger.warn = "Deleting NVRAM file of #{config.vm.box}"
#    trigger.run = { inline: <<-SHELL
#        VM_NAME="#{config.vm.box}"
#        NVRAM_PATH=$(virsh dumpxml $VM_NAME | grep "nvram" | sed 's/.*nvram="\([^"]*\)".*/\1/')
#        echo "Deleting NVRAM file at: $NVRAM_PATH"
#        # Remove the NVRAM file
#        #rm -f $NVRAM_PATH
#      SHELL
#    }
  end

  # no autoupdate if vagrant-vbguest is installed
  if Vagrant.has_plugin?("vagrant-vbguest") then
    config.vbguest.auto_update = false
  end
  config.vm.boot_timeout = 600
  config.vm.graceful_halt_timeout = 600
  config.winrm.retry_limit = 30
  config.winrm.retry_delay = 10
  config.ssh.connect_retry_delay = 10
  config.ssh.connect_retries = 5
  config.winrm.ssl_peer_verification = false
  config.winrm.transport = "plaintext" # negociate, ssl, plaintext
  config.winrm.basic_auth_only = true  #if true => plaintext transport
  config.winrm.username = "vagrant"
  config.winrm.password = "vagrant"
  config.ssh.insert_key = false
  config.ssh.username = "vagrant"
  config.ssh.password = "vagrant"

  config.vm.provider :libvirt do |libvirt|
    ## Use QEMU session instead of system connection
    #libvirt.qemu_use_session = true
    ## URI of QEMU session connection, default is as below
    #libvirt.uri = 'qemu:///session'
    ## URI of QEMU system connection, use to obtain IP address for management, default is below
    #libvirt.system_uri = 'qemu:///system'
    ## Path to store Libvirt images for the virtual machine, default is as ~/.local/share/libvirt/images
    #libvirt.storage_pool_path = '/home/user/.local/share/libvirt/images'
    ## Management network device, default is below
    #libvirt.management_network_device = 'virbr0'
    libvirt.management_network_address = "#{management_network_prefix}.0/24"
    libvirt.management_network_name = "plaber_mgnt"
    libvirt.management_network_mode = "none"
    libvirt.storage_pool_name = storage_pool_name
  end

  box_defs.each do |box_def|
    config.vm.define box_def[:bname] do |box|
      box.vm.provider "libvirt" do |box_provider|
        #box_provider.graphics_type = "vnc"
        box_provider.default_prefix = "plaber_"
        box_provider.memory = box_def[:ram]
        box_provider.cpus = box_def[:cpu]
        box_provider.keymap = "fr"
        box_provider.input type:"tablet", bus: "usb" # solve mouse capture of VNC
        if box_def[:firmware] == "uefi"
          unless File.exist?("#{efi_path}/OVMF_CODE_4M.ms.fd")
            FileUtils.cp("../../ovmf/usr/share/OVMF/OVMF_CODE_4M.ms.fd", "#{efi_path}/OVMF_CODE_4M.ms.fd")
            FileUtils.chmod(permissions, "#{efi_path}/OVMF_CODE_4M.ms.fd")
          end
          unless File.exist?("#{efi_path}/#{box_def[:bname]}_OVMF_VARS.4M.ms.fd")
            FileUtils.cp("../../ovmf/usr/share/OVMF/OVMF_VARS_4M.ms.fd", "#{efi_path}/#{box_def[:bname]}_OVMF_VARS.4M.ms.fd")
            FileUtils.chmod(permissions, "#{efi_path}/#{box_def[:bname]}_OVMF_VARS.4M.ms.fd")
          end
          box_provider.nvram = "#{efi_path}/#{box_def[:bname]}_OVMF_VARS.4M.ms.fd"
          box_provider.loader = "#{efi_path}/OVMF_CODE_4M.ms.fd"
          box_provider.machine_type = 'q35'
          ## Requires swtpm and swtpm-tools
          box_provider.tpm_model = "tpm-crb"
          box_provider.tpm_type = "emulator"
          box_provider.tpm_version = "2.0"
          # box_provider.tpm_path =
          box_provider.video_vram = 16384
          box_provider.graphics_type = "spice"
          box_provider.video_type = "virtio"

          #box_provider.launchsecurity :type => 'sev', :cbitpos => 47, :reducedPhysBits => 1, :policy => "0x0003"
          #box_provider.memtune :type => "hard_limit", :value => 2500000 # Note here the value in kB (not in Mb)
#          #box_provider.customize ["modifyvm", :id, '--audio-driver', 'alsa', '--audio-controller', 'hda', '--audio-enabled', 'on']
#          #box_provider.customize ["modifyvm", :id, '--vram', '128']
#          box_provider.customize ["modifyvm", :id, '--nested-hw-virt', 'on']
#          box_provider.customize ["modifyvm", :id, '--firmware', 'efi64']
#          box_provider.customize ["modifynvram", :id, 'inituefivarstore']
#          box_provider.customize ["modifynvram", :id, 'enrollorclpk']
#          box_provider.customize ["modifynvram", :id, 'enrollmssignatures']
        end
      end
      if box_def.has_key?(:username)
        box.ssh.username = box_def[:username] 
        box.winrm.username = box_def[:username]
      end
      if box_def.has_key?(:password)
        box.ssh.password = box_def[:password]
        box.winrm.password = box_def[:password]
      end
      box.ssh.insert_key = false  # prevent Vagrant from overriding the authorized_keys
      # Download image
      box.vm.box_download_insecure = box_def[:box_img]
      box.vm.box = box_def[:box_img]
      if box_def.has_key?(:box_img_version)
        box.vm.box_version = box_def[:box_img_version]
      end
      # issue when creating sync folder
      box.vm.synced_folder '.', '/vagrant', disabled: true
      ## Network provisionning
      if box_def[:role] == "member"
        n_info = box_def[:net]
        #  Provision INTERNAL on Ethernet / eth1
        box.vm.network :private_network, 
          #libvirt__guest_ipv6: "no",
          libvirt__forward_mode: "none",
          #libvirt__network_address: "#{n_info[:network]}.0",
          libvirt__netmask: n_info[:mask],
          #libvirt__dhcp_enabled: false,
          libvirt__network_name: n_info[:name],
          ip: "#{n_info[:network]}.#{box_def[:relative_ip]}"
        #  Provision a BRIDGED interface if needed on Ethernet 2 / eth2
        if box_def.has_key?(:ip_p)
          box.vm.network :public_network, 
            dev: bridge[:dev],
            mode: "bridge",
            type: "bridge",
            libvirt__iface_name: bridge[:name],
            ip: box_def[:ip_p]
        end
      end
      if box_def[:role] == "firewall"
        #  Provision a BRIDGED interface on eth1 
        box.vm.network :public_network, 
          dev: bridge[:dev],
          mode: "bridge",
          type: "bridge",
          libvirt__iface_name: bridge[:name],
          ip: box_def[:ip_p]
          box_def[:nets].each do |bn|
          # Provision INTERNAL interfaces on eth{i}  
          n_info = bn[:net]
          puts "  Provision Network #{n_info[:name]} with IP #{n_info[:network]}.0"
          box.vm.network :private_network, 
            #libvirt__guest_ipv6: "no",
            libvirt__forward_mode: "none",
            #libvirt__network_address: "#{n_info[:network]}.0",
            libvirt__netmask: n_info[:mask],
            #libvirt__dhcp_enabled: false,
            libvirt__network_name: n_info[:name],
            ip: "#{n_info[:network]}.#{bn[:relative_ip]}"
        end
      end
      # Windows specific
      if box_def[:bname] == "bastion"
        box.vm.communicator = :none
      end
      # Windows specific
      if box_def[:os] == "windows"
        box.vm.guest = :windows
        # bypass winrm problems
        box.vm.communicator = "winssh"
        config.winssh.shell = 'powershell'
        #config.vm.communicator = 'winrm'
        box.vm.provision :shell, :path => "../../scripts/rename-interface.ps1", privileged: false, args: ["-IFName", "mgt", "-NetPrefix", management_network_prefix]
        n_info = box_def[:net]
        box.vm.provision :shell, :path => "../../scripts/rename-interface.ps1", privileged: false, args: ["-IFName", "lab", "-NetPrefix", n_info[:network]]
        box.vm.provision :shell, :path => "../../scripts/flush-interface.ps1", privileged: false, args: ["-IFName", "lab"]
        box.vm.provision :shell, :path => "../../scripts/EnableWinRM.ps1", privileged: false
        box.vm.provision :shell, :path => "../../scripts/default_gw.ps1", privileged: false, args: ["-IFName", "lab","-Gateway", n_info[:gw]]
        if box_def.has_key?(:ip_p)
          #n_info_p = net_defs[:bridge]
          box.vm.provision :shell, :path => "../../scripts/rename-interface.ps1", privileged: false, args: ["-IFName", "internet", "-NetPrefix", bridge[:network]]
          box.vm.provision :shell, :path => "../../scripts/flush-interface.ps1", privileged: false, args: ["-IFName", "lab"]
          box.vm.provision :shell, :path => "../../scripts/fix_ip.ps1", privileged: false, args: ["-IFName", "internet", "-IP", box_def[:ip_p], "-Mask", bridge[:mask]]
        end
      end
      # Arch specific
      if box_def[:os] == "arch"
        #box.vm.guest = :linux
        #box.vm.network :public_network, bridge: n_info_p[:name], ip: box_def[:ip_p]
        box.vm.communicator = "ssh"
        box.vm.provision :shell, :path => "../../scripts/fix_ip.sh", privileged: true, args: [box_def[:deployment_type], bridge[:gw]]
        box.vm.provision :shell, :path => "../../scripts/arch_python.sh", privileged: true, args: ["France"]
      end
      # Linux specific
      #if box_def[:os] == "linux"
      #  box.vm.guest = :linux
      #  box.vm.communicator = "ssh"
      #  #  alway provision an internal network on Ethernet 2
      #  n_info = box_def[:net]
      #  box.vm.network :private_network, ip: box_def[:ip], virtualbox__intnet: n_info[:name]
      #  box.vm.provision :shell, :path => "../../scripts/fix_ip_ubuntu.sh", privileged: true, args: [n_info[:gw]]
      #end
      #if box_def.has_key?(:forwarded_port)
      #  # forwarded port explicit
      #  box_def[:forwarded_port] do |forwarded_port|
      #    box.vm.network :forwarded_port, guest: forwarded_port[:guest], host: forwarded_port[:host], host_ip: "127.0.0.1", id: forwarded_port[:id]
      #  end
      #end
    end
  end
end
